---
title: "pertvimp-vignette"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{pertvimp-vignette}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

# Introduction to pertvimp package

## Theoretical background

Put there nicely and concisely written content of the slides "Permutation scheme" --> "Pooling: Non-parametric estimates of small p-values" together with necessary formulas.

## Quick start

The purpose of this section is to give users a general idea of the package. We will briefly go through the main functions, possible values of their arguments, outputs and their interpretation. 

First, let's install the `pertvimp` package. The `pertvimp` package is not (yet!) available on Cran, but you can install the development version like this:

``` {r, eval = FALSE}
devtools::install_gitlab("oktawia.miluch/pertvimp-package", host = "gitlab.staburo.de")
```

Then, we load necessary packages:
```{r setup, warning = FALSE, message = FALSE}
library(pertvimp)
library(magrittr)
library(dplyr)

if (requireNamespace("AppliedPredictiveModeling", quietly = TRUE)) {
    library(AppliedPredictiveModeling)
} else {
    stop("Package 'AppliedPredictiveModeling' is required for this vignette. Please install it.")
}

```

In the examples below we use Alzheimerâ€™s Disease CSF Data from the `AppliedPredictiveModeling` package. To reduce the time needed to build this vignette, we use the subset of the original data (100 observations taken from the original dataset) and smaller than recommended values of `nsims` parameters.If you are working on a real-life example, please keep the default values of `nsims` or at least increase the values used below. In the example below, we show the basic usage of our package with the default settings. By default, the functions of this package use sequential computation and display informative covariates according to the pooled p-values. The default settings also display all possible p-values, namely unadjusted, FWER-adjusted and FDR-adjusted.

```{r ex_default}
data(AlzheimerDisease)
data_alz <- cbind(diagnosis, predictors)
# To make the results reproducible
set.seed(786)
data_sub <- slice_sample(data_alz, n = 100)
vimp_def <- vim_perm_sim_wrapper(nsims = c(20,30,50), entire_data = data_sub, outcome_var = "diagnosis")

```

As shown below, in this case none of the variables are informative when applying the Holm p-value correction (column `FWER_confirmed`). Using the FDR p-value correction, the first 5 covariates appear to be informative.  

````{r ex_default2}
vimp_def$final_dec_pooled %>% 
  select(-quantile_pooled) %>% 
  head()
````

## Decide what will be stored in your output

The `vim_perm_sim_wrapper()` function has a `save_vimp_history` argument. This argument allows the user to decide what should be saved in the output object. By default it is set to `"all"`, which means that variable importance measures from all steps of the procedure are saved. Returning to the object created in the previous paragraph, one can inspect the variable importance from the simulations performed in the first or second step of the procedure by running:

````{r inspect_history1}
# VIMP history from the 1st step
vimp_def$pre_selection$step_1$vimp_history %>% 
  select(1:6) %>% 
  head()

# VIMP history from the 2nd step
vimp_def$pre_selection$step_2$vimp_history %>%
  select(1:6) %>% 
  head()
````

The code below allows you to check the VIMP (Variable Importance) measures from the last step:

````{r vimp_last_step}
vimp_def$vimp_history %>% 
  select(1:6) %>% 
  head()
````

Setting the parameter `save_vimp_history` to the value `"last"` will only save the variable importance from the last step of the procedure. Compared to the default setting (which sets `save_vimp_history` to `"all"`), under `pre_selection$step_1` or `pre_selection$step_2` there will be no data frame storing the variable importance obtained during the preselection phase. 

````{r vimp_last}
vimp_last <- vim_perm_sim_wrapper(nsims = c(20,30,50), entire_data = data_sub, outcome_var = "diagnosis", save_vimp_history = "last")

# Inspect VIMP from the last step of the procedure
vimp_last$vimp_history %>%
  select(1:6) %>% 
  head()

# There is no `vimp_history`data frame under `pre_selection$step_1` or `pre_selection$step_2`
# vimp_last$pre_selection$step_1
# vimp_last$pre_selection$step_2
````

If the parameter `save_vimp_history` is set to the value `"none"`, the variable importance of each step will not be saved. As shown below, under `vimp_history` there is no longer a data frame to store variable importance measures. Similarly, if you run `vimp_none$pre_selection$step_1` or `vimp_none$pre_selection$step_2`, as in the previous example, you will no longer find data frames storing VIMP from the preselection phase.

````{r vimp_none}
vimp_none <- vim_perm_sim_wrapper(nsims = c(20,30,50), entire_data = data_sub, outcome_var = "diagnosis", save_vimp_history = "none")
vimp_none$vimp_history

````

## Parallelisation

To speed up the computation, it is possible to run the main function of the `pertvimp` package in parallel. There are two ways to do this. The first is to use the parallelisation provided by the `ranger::ranger()` function, which is used internally. To use this functionality, the `num.threads` parameter must be set to a value greater than 1.

````{r parallel1}
vimp_parallel1 <- vim_perm_sim_wrapper(nsims = c(20,30,50), entire_data = data_sub, outcome_var = "diagnosis", num.threads = 4)
````

Another way to perform parallel computations is to set the `num_cores_parallel` parameter to a value greater than 1. In this case, a cluster with the specified number of cores is created under the hood.

````{r parallel2}
vimp_parallel2 <- vim_perm_sim_wrapper(nsims = c(20,30,50), entire_data = data_sub, outcome_var = "diagnosis", num_cores_parallel = 4)
````

Of course, it is possible to use two types of parallelisation at the same time, but this is not recommended by the authors of the package. In any case, it is important to set the value of these parameters so that they do not exceed the number of cores available on your machine. If you are unsure about the number of cores available on your machine, run `parallel::detectCores()`. Note that if you are working with small datasets or too small values of the `nsims` parameter, the benefit of parallelisation (if any) will be negligible.
 
## Choose decision criteria (pooled or per variable p-value)

The `pertvimp` package also provides an option to select informative covariates based on the `per variable` p-values. By default, the printed decision whether a covariate is informative or not is based on the pooled p-value. In the output below, the decision about the informativeness of covariates is based on the per-variable p-value:

````{r per_variable}
vimp_per_variable <- vim_perm_sim_wrapper(nsims = c(20,30,50), entire_data = data_sub, outcome_var = "diagnosis", method = "per_variable")

vimp_per_variable$final_dec_per_variable %>% 
  select(-quantile_per_variable) %>%
  head()
````

As shown in the output above, when using p-values per variable, after applying FWER or FDR correction, no variable appears to be informative. At this point it is very important to remind the reader that (in order to reduce the time needed to compile this vignette) the values of the `nsims` parameter used in this example are much too low. To get reliable results, `nsims` should be set to higher values.

## Additional entries in the output

So far we have discussed the contents of the `vimp_history` and `final_dec_pooled` (or `final_dec_per_variable`) elements stored in the output of the `vim_perm_sim_wrapper()` function. Besides that, there are a few other items stored in the output. To demonstrate some of them, let's use the output from the previous paragraph again. As shown below, the `alpha` entry stores the value of the significance level $\alpha$ used in the last step of the procedure:

````{r alpha}
vimp_per_variable$alpha
````

The next element in the output of the `vim_perm_sim_wrapper()` function is the `result_taken_from_previous_step` entry.  If `result_taken_from_previous_step` is `TRUE`, then no variables survived the preselection process, so the reported results are taken from one of the previous steps. If it is set to `FALSE` (as below), the results presented in the output have been obtained in the last step of the procedure.

````{r from_last_step}
vimp_per_variable$result_taken_from_previous_step
````

`time_elapsed` is a list containing the runtime of each step and the total time taken to execute the code, while `call` stores the call formula used to generate the output.

````{r time}
vimp_per_variable$time_elapsed
vimp_per_variable$call
````

Another entry in the output object is the `control_parameters' list. The user can specify what else should be stored in this list, but by default only the number of simulations from the last step is stored (see below).

````{r control_params}
# The default
vimp_per_variable$control_parameters
````

Let's say we want to select the informative covariates based on the per variable  p-values, and we want to store the type of p-values used in the `control_parameters` list. To do this, we need to execute the following code:

<!-- # TODO : remove warnings = FALSE once you resolve the underlying issue  -->

````{r add_control, warning = FALSE}
# Custom `control_parameters` list
vimp_per_var_control <- vim_perm_sim_wrapper(nsims = c(20,30,50), entire_data = data_sub, outcome_var = "diagnosis", method = "per_variable", p_val_type = c("per variable p-value"))

vimp_per_var_control$control_parameters
````

The last entry in the output of the `vim_perm_sim_wrapper()` function is the `pre_selection` list. This list consists of two sublists: `step_1` and `step_2`. Let's focus on the `step_1` sublist (the structure of `step_2` is identical). By default, this list has the following 4 elements:

- `vimp_history` - data frame storing variable importance measures,
- `decision_per_variable` - data frame with p-values and decision whether a given covariate is informative,
- `alpha` - the significance level used in the first step of the procedure,
- `control_parameters` - by default the value of the `nsims` parameter used in the first step, but also, as shown below, the character indicating the type of p-values on which the final decision was based.

The structure of the `pre_selection` list changes only if the user sets the parameter `save_vimp_history` to `last` or `none`. If one of these two options is chosen, there will be no `vimp_history` data frame for any of the preselection steps. The structure of the remaining three elements remains unchanged.

The code below demonstrates the described entries based on the example of the `vimp_per_var_control` object created in the previous chunk of code.

````{r pre_selection}
# VIMP from 1st step
vimp_per_var_control$pre_selection$step_1$vimp_history %>% 
  select(1:6) %>% 
  head()

# Which covariates were considered as informative in the 1st step?
vimp_per_var_control$pre_selection$step_1$decision_per_variable %>% 
  select(-quantile_per_variable) %>% 
  head()

# The significance level used in the 1st step
vimp_per_var_control$pre_selection$step_1$alpha

# Control parameters used in the 1st step
vimp_per_var_control$pre_selection$step_1$control_parameters

````

## Plot your results

Let's use again the results obtained at the beginning of this tutorial, namely the following object:

````{r reminder,  eval = FALSE}
vimp_def <- vim_perm_sim_wrapper(nsims = c(20,30,50), entire_data = data_sub, outcome_var = "diagnosis")

````

Instead of just looking at the table that stores the decisions from the last step about informative covariates, we would like to have an appealing visual representation of our results. In the `pertvimp` package this is easily accessible using the `plot_vimps()` function. If you want to plot the results based on the pooled p-values, just specify the output of the `vim_perm_sim_wrapper()` function as shown below: 

````{r plot_base, fig.width=13, fig.asp=0.8, out.width="115%"}
plot_vimps(wrapper_object = vimp_def)
````

The boxplots from the figure above show the VIMP measures obtained for each covariate from the `nsims` simulations performed in the last step of the procedure. The numbers on the left of the boxplots are unadjusted, FDR-adjusted and FWER-adjusted p-values respectively. To control the size of the plotted p-values, increase the value of the `text_size` parameter in the `plot_vimps()` function. It is set to 3 by default.

If you only want to display a certain number of covariates, let's say 10, you can do this by setting the `filter_vars` parameter to the desired value, as shown below:

````{r filter_vars, fig.width=13, fig.asp=0.8, out.width="115%"}
plot_vimps(wrapper_object = vimp_def, filter_vars = 10, text_size = 4)
````

If you are working with a large dataset and many covariates survive to the last step of the procedure, it is recommended to specify the value of the `filter_vars` parameter to keep your plot readable.

Let's use again the results of the proposed procedure based on per variable p-values (other parameters remain at their default values):

````{r plot_per_var, eval=FALSE}
vimp_per_variable <- vim_perm_sim_wrapper(nsims = c(20,30,50), entire_data = data_sub, outcome_var = "diagnosis", method = "per_variable")
````

To use the `plot_vimps()` function for results based on per variable p-values, the `pooled` parameter in the plot function must be set to `FALSE`:

````{r plot_per_var2, fig.width=13, fig.asp=0.8, out.width="115%"}
plot_vimps(wrapper_object = vimp_per_variable, pooled = FALSE)
````

